<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="title: Hello World缘起随着第三代半导体产业的持续发力，功率器件的动态性能测试已经不仅仅是在实验室的R&amp;D环境下进行了，很多厂商也逐渐在产线环境下进行测试。产线测试环境与实验室R&amp;D测试环境截然不同，在实验室中，测试可以通过手动的方式进行；但是在产线上，测试只能以全自动化的方式进行；并且产线自动化测试对无故障时间，UPH（Units per Hour），以及效率的">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2024/12/01/%E8%AE%B0%E5%BD%95%E7%A8%8B%E6%8E%A7%E4%BC%A0%E8%BE%93%E6%B3%A2%E5%BD%A2%E7%9A%84%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title: Hello World缘起随着第三代半导体产业的持续发力，功率器件的动态性能测试已经不仅仅是在实验室的R&amp;D环境下进行了，很多厂商也逐渐在产线环境下进行测试。产线测试环境与实验室R&amp;D测试环境截然不同，在实验室中，测试可以通过手动的方式进行；但是在产线上，测试只能以全自动化的方式进行；并且产线自动化测试对无故障时间，UPH（Units per Hour），以及效率的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-12-01T11:20:12.350Z">
<meta property="article:modified_time" content="2024-12-01T13:11:20.965Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-记录程控传输波形的速度优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/%E8%AE%B0%E5%BD%95%E7%A8%8B%E6%8E%A7%E4%BC%A0%E8%BE%93%E6%B3%A2%E5%BD%A2%E7%9A%84%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2024-12-01T11:20:12.350Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="title-Hello-World"><a href="#title-Hello-World" class="headerlink" title="title: Hello World"></a>title: Hello World</h2><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>随着第三代半导体产业的持续发力，功率器件的动态性能测试已经不仅仅是在实验室的R&amp;D环境下进行了，很多厂商也逐渐在产线环境下进行测试。产线测试环境与实验室R&amp;D测试环境截然不同，在实验室中，测试可以通过手动的方式进行；但是在产线上，测试只能以全自动化的方式进行；并且产线自动化测试对无故障时间，UPH（Units per Hour），以及效率的要求很高，这对开发自动化软件提出了苛刻的要求。</p>
<p>最近，我们的系统集成商忱芯在基于MSO58LP示波器开发自动化<strong>双脉冲测试</strong>时就遇到了困难。整个双脉冲测试大概分为如下五步：</p>
<ol>
<li>检查诸仪器状态</li>
<li>高压源对电容充电</li>
<li>信号源进行双脉冲动作同时示波器采集数据 </li>
<li>程控波形数据的传输</li>
<li>算法后处理。</li>
</ol>
<p>市面上目前存在的自动化厂商有：联动科技，LAMSYS，Kwell等，竞争对手最快可以在1s时间内完成整个双脉冲测试。忱芯的两个客户<strong>联合电子</strong>（<a target="_blank" rel="noopener" href="https://www.uaes.com/servlet/portal/index.html">UAES.com</a>）和<strong>斯达半导体</strong>（<a target="_blank" rel="noopener" href="http://www.powersemi.cc/">嘉兴斯达半导体股份有限公司</a>），其中<strong>联合电子</strong>（<a target="_blank" rel="noopener" href="https://www.uaes.com/servlet/portal/index.html">UAES.com</a>）要求在1.5s内完成整个双脉冲测试，<strong>斯达半导体</strong>（<a target="_blank" rel="noopener" href="http://www.powersemi.cc/">嘉兴斯达半导体股份有限公司</a>）则要求在1s内完成整个双脉冲测试。因此忱芯也想要达到甚至超过这一水平，但是仅仅在第4步程控波形数据的传输就花费了1.1s的时间。根据忱芯的测算，若要满足联合电子的要求，第4步必须要在0.6s时间内完成，而若要满足斯达半导体的要求，第4步则需要在0.2s时间内完成。</p>
<p>忱芯的程控波形数据传输的方案是：</p>
<ul>
<li>先将工控机的某一个文件夹映射到MSO58LP示波器的远程文件夹上；</li>
<li>示波器完成数据采集后，将波形以*.csv格式存储到这个远程文件夹；</li>
<li>工控机在本地读取这个文件夹里已经保存好的*csv格式的文件；</li>
</ul>
<p>这一方案在实际中会遇到两个问题：第一个问题就是前面提到的要花费1.1s的时间，这是不可接受的；第二个问题则是*.csv格式的波形文件由于是保存在远程文件夹，因此存在概率性地无法保存成功。</p>
<p>至此，忱芯在开发自动化软件时就遇到了瓶颈，他们就找到了我们泰克来解决这个问题。</p>
<h1 id="迈出第一步"><a href="#迈出第一步" class="headerlink" title="迈出第一步"></a>迈出第一步</h1><p>由于客户将波形存成*.csv格式，在远程读取这个文件做后处理，存在概率性的bug，因此我这边提供了一个通用的直接读取示波器内存里的二进制波形文件的函数<code>transfer_wfm</code>，整个函数的定义如下：</p>
<figure class="highlight plaintext"><figcaption><span>startFrom</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">def transfer_wfm(scope, channel):</span><br><span class="line">    ############################################################################    </span><br><span class="line">    if channel not in scope.query(&#x27;DATa:SOUrce:AVAILable?&#x27;):</span><br><span class="line">        print(&#x27;the specified channel is not active&#x27;)</span><br><span class="line">        return 0 </span><br><span class="line">	</span><br><span class="line">    scope.write(&#x27;DATa:SOUrce %s&#x27;%channel)</span><br><span class="line">    #scope.query(&#x27;DATa:SOUrce?&#x27;)</span><br><span class="line">    ############################################################################</span><br><span class="line">	</span><br><span class="line">    ############################################################################</span><br><span class="line">    scope.write(&#x27;DATa:ENCdg RIBinary&#x27;)</span><br><span class="line">    #scope.query(&#x27;DATa:ENCdg?&#x27;)</span><br><span class="line">    </span><br><span class="line">    scope.write(&#x27;WFMOutpre:BYT_Nr 2&#x27;)</span><br><span class="line">    #scope.query(&#x27;WFMOutpre:BYT_Nr?&#x27;)</span><br><span class="line">    </span><br><span class="line">    ## get the waveform encoding infos</span><br><span class="line">    data_format         = scope.query(&#x27;WFMOutpre:BN_Fmt?&#x27;)</span><br><span class="line">    nbytes_per_point    = int( scope.query(&#x27;WFMOutpre:BYT_Nr?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">       </span><br><span class="line">    record_length       = int( scope.query(&#x27;HORizontal:RECOrdlength?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line"></span><br><span class="line">    scope.write(&#x27;DATa:STOP 1&#x27;)</span><br><span class="line">    #scope.query(&#x27;DATa:STARt?&#x27;)    </span><br><span class="line">    scope.write(&#x27;DATa:STOP %s&#x27;% record_length)</span><br><span class="line">    #scope.query(&#x27;DATa:STOP?&#x27;)</span><br><span class="line">    ############################################################################ </span><br><span class="line">    </span><br><span class="line">    ############################################################################ </span><br><span class="line">    ## get the horizontal infos</span><br><span class="line">    horiz_xzero         = float( scope.query(&#x27;WFMOutpre:XZEro?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    horiz_xincr         = float( scope.query(&#x27;WFMOutpre:XINcr?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    horiz_pt_offset     = int( scope.query(&#x27;WFMOutpre:PT_Off?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">	</span><br><span class="line">    ## get the vertical infos</span><br><span class="line">    digit_zero          = float( scope.query(&#x27;WFMOutpre:YZEro?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    digit_scale         = float( scope.query(&#x27;WFMOutpre:YMUlt?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    digit_offset        = float( scope.query(&#x27;WFMOutpre:YOFf?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    ############################################################################</span><br><span class="line">       </span><br><span class="line">    ############################################################################    </span><br><span class="line">    ## get the waveform data   </span><br><span class="line">    scope.write(&#x27;CURVE?&#x27;)</span><br><span class="line">    raw_data            = scope.read_raw()</span><br><span class="line">    ############################################################################ </span><br><span class="line">	</span><br><span class="line">    ############################################################################</span><br><span class="line">    ## calculate the time axis  </span><br><span class="line">    time_data           = horiz_xzero + (np.arange(record_length) - horiz_pt_offset) * horiz_xincr</span><br><span class="line">    </span><br><span class="line">    ## calculate the voltage axis</span><br><span class="line">    data_start_pos      = int( raw_data[1:2].decode(&#x27;ascii&#x27;), 16) + 2</span><br><span class="line">    current_pos         = 0</span><br><span class="line">    volt_data           = []</span><br><span class="line">        </span><br><span class="line">    if &#x27;RI&#x27; in data_format:</span><br><span class="line">        if nbytes_per_point == 1:        </span><br><span class="line">            unpack_fmt = &#x27;&gt;b&#x27;</span><br><span class="line">        elif nbytes_per_point == 2:</span><br><span class="line">            unpack_fmt = &#x27;&gt;h&#x27;        </span><br><span class="line">        elif nbytes_per_point == 4:  </span><br><span class="line">            unpack_fmt = &#x27;&gt;l&#x27;  </span><br><span class="line">            </span><br><span class="line">        for idx in range(record_length):</span><br><span class="line">            current_pos         = data_start_pos + nbytes_per_point*idx</span><br><span class="line">            current_point       = raw_data[current_pos:current_pos + nbytes_per_point]</span><br><span class="line">            current_volt_data   = digit_zero + digit_scale*(struct.unpack(unpack_fmt,current_point)[0] - digit_offset)</span><br><span class="line">            volt_data.append(current_volt_data)                     </span><br><span class="line">    </span><br><span class="line">    volt_data    = np.array(volt_data)</span><br><span class="line">    ############################################################################</span><br><span class="line"></span><br><span class="line">    return time_data, volt_data</span><br></pre></td></tr></table></figure>

<p>这个函数是没有针对任何特殊场景进行优化，并且每次只能采集一个通道的波形数据。</p>
<p>在客户的现场，客户需要采集6个通道的数据，采样率为625 MSps，记录长度为250 Kpts，我们使用如下代码进行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    rm = visa.ResourceManager()</span><br><span class="line">    print(rm.list_resources())</span><br><span class="line">    resource_address= &#x27;TCPIP0::10.42.18.115::inst0::INSTR&#x27;</span><br><span class="line">    </span><br><span class="line">    scope           = rm.open_resource(resource_address)</span><br><span class="line">    scope.timeout   = 4000</span><br><span class="line">    print( scope.query(&quot;*IDN?&quot;) )    </span><br><span class="line">    scope.write(&#x27;HEADer OFF&#x27;)</span><br><span class="line">    ############################################################################</span><br><span class="line">    </span><br><span class="line">    ############################################################################ </span><br><span class="line">    start = time.time()</span><br><span class="line">    record_length           = int( scope.query(&#x27;HORizontal:RECOrdlength?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    volt_data               = np.zeros((6, record_length))</span><br><span class="line">    time_data, volt_data[0] = transfer_wfm(scope, &#x27;CH1&#x27;)</span><br><span class="line">    _,         volt_data[1] = transfer_wfm(scope, &#x27;CH2&#x27;)</span><br><span class="line">    _,         volt_data[2] = transfer_wfm(scope, &#x27;CH3&#x27;)</span><br><span class="line">    _,         volt_data[3] = transfer_wfm(scope, &#x27;CH4&#x27;)</span><br><span class="line">    _,         volt_data[4] = transfer_wfm(scope, &#x27;CH5&#x27;)</span><br><span class="line">    _,         volt_data[5] = transfer_wfm(scope, &#x27;CH6&#x27;)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the total time is &#x27;, end-start,&#x27;s&#x27;)</span><br><span class="line"></span><br><span class="line">    plt.plot(time_data, volt_data[0])</span><br><span class="line">    plt.plot(time_data, volt_data[1])  </span><br><span class="line">    plt.plot(time_data, volt_data[2])</span><br><span class="line">    plt.plot(time_data, volt_data[3])</span><br><span class="line">    plt.plot(time_data, volt_data[4])</span><br><span class="line">    plt.plot(time_data, volt_data[5]) </span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br><span class="line">    ############################################################################</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(&#x27;TCPIP0::10.42.18.68::inst0::INSTR&#x27;, &#x27;TCPIP0::10.42.19.60::inst0::INSTR&#x27;, &#x27;TCPIP0::10.42.18.115::inst0::INSTR&#x27;, &#x27;ASRL10::INSTR&#x27;)</span><br><span class="line">&gt;TEKTRONIX,MSO58B,C053854,CF:91.1CT FV:1.44.3.433</span><br><span class="line">&gt;the total time is  2.6043059825897217 s</span><br></pre></td></tr></table></figure>

<p>这一结果甚至比直接使用CSV转存的方法时间还要长。这是不可接受了。基于此，并且也为了更清楚客户的现场使用情况，叶昊生和王芳芳决定到达客户现场，实际看看并面对面和客户进行沟通。</p>
<h1 id="Go-to-Gemba"><a href="#Go-to-Gemba" class="headerlink" title="Go to Gemba"></a>Go to Gemba</h1><p>在现场，我们发现，实际上客户并不需要全部的250k记录长度（每通道）的数据，因此客户同意将记录长度减小到125k（每通道），并且我们粗略地分析整个2.6s的时间花费在哪些地方，我们发现读取波形的<strong>垂直设置信息</strong>和**6次读取CURVE?**命令花费了太多了时间；因此当时的重点是把速度优化方向放在这两个地方：</p>
<ul>
<li>客户告诉我们其实他们的垂直档位在整个测试过程中并不会发生变化，因此并不需要重复读取波形的垂直设置信息；</li>
<li>另外，查阅我们的编程手册，发现其实CURVE?命令支持一次性读取多通道的波形数据；</li>
</ul>
<p>基于上面两点的优化分析，我们重新编写了一个多通道的波形传输函数<code>transfer_wfm_se</code>，实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">def transfer_wfm_se(scope, channel_list, digit_scale_list, digit_offset_list, digit_zero_list, data_start, data_stop):</span><br><span class="line">    ############################################################################</span><br><span class="line">    ## specify channel sources of the transferred waveforms</span><br><span class="line">    start = time.time()</span><br><span class="line">	</span><br><span class="line">    channel_list_str    = &#x27;&#x27;</span><br><span class="line">    channel_list_len    = len(channel_list)</span><br><span class="line">	</span><br><span class="line">    data_len = data_stop - data_start + 1</span><br><span class="line"></span><br><span class="line">    for channel in channel_list:</span><br><span class="line">        channel_list_str = channel_list_str + channel + &#x27;, &#x27;</span><br><span class="line">    channel_list_str = channel_list_str[0:-2]</span><br><span class="line">    scope.write(&#x27;DATa:SOUrce %s&#x27;%channel_list_str)</span><br><span class="line">    #scope.query(&#x27;DATa:SOUrce?&#x27;)</span><br><span class="line">    </span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for specifying data source is &#x27;, end-start,&#x27;s&#x27;) </span><br><span class="line">    ############################################################################</span><br><span class="line">	</span><br><span class="line">    ############################################################################</span><br><span class="line">    scope.write(&#x27;DATa:ENCdg RIBinary&#x27;)</span><br><span class="line">    #scope.query(&#x27;DATa:ENCdg?&#x27;)</span><br><span class="line">    </span><br><span class="line">    scope.write(&#x27;WFMOutpre:BYT_Nr 2&#x27;)</span><br><span class="line">    #scope.query(&#x27;WFMOutpre:BYT_Nr?&#x27;)</span><br><span class="line">	</span><br><span class="line">    start = time.time()</span><br><span class="line">    scope.write(&#x27;DATa:STARt %s&#x27;% data_start)   </span><br><span class="line">    scope.write(&#x27;DATa:STOP %s&#x27;% data_stop)</span><br><span class="line">    #scope.query(&#x27;DATa:STARt?&#x27;)</span><br><span class="line">    #scope.query(&#x27;DATa:STOP?&#x27;)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for specifying data start/stop is &#x27;, end-start,&#x27;s&#x27;)  </span><br><span class="line">	</span><br><span class="line">    ## get the waveform encoding infos</span><br><span class="line">    start = time.time()</span><br><span class="line">    data_format         = scope.query(&#x27;WFMOutpre:BN_Fmt?&#x27;)</span><br><span class="line">    nbytes_per_point    = int( scope.query(&#x27;WFMOutpre:BYT_Nr?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for getting the waveform encoding infos is &#x27;, end-start,&#x27;s&#x27;)   </span><br><span class="line"></span><br><span class="line">    ## get the horizontal infos</span><br><span class="line">    start = time.time()</span><br><span class="line">    horiz_xincr         = float( scope.query(&#x27;WFMOutpre:XINcr?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    horiz_zero          = float( scope.query(&#x27;WFMOutpre:XZEro?&#x27;).rstrip(&#x27;\n&#x27;) )   </span><br><span class="line">    horiz_pt_offset     = int( scope.query(&#x27;WFMOutpre:PT_Off?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for getting the horizontal infos is &#x27;, end-start,&#x27;s&#x27;)     </span><br><span class="line">    ############################################################################</span><br><span class="line">	  </span><br><span class="line">    ############################################################################</span><br><span class="line">    ## get the waveform data</span><br><span class="line">    start = time.time()</span><br><span class="line">    scope.write(&#x27;CURVE?&#x27;)</span><br><span class="line">    raw_data            = scope.read_raw()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for CURVE? query is &#x27;, end-start,&#x27;s&#x27;) </span><br><span class="line">    ############################################################################</span><br><span class="line">	</span><br><span class="line">    ############################################################################</span><br><span class="line">    ## post-processing for curve raw data to real voltage data</span><br><span class="line">    start = time.time()</span><br><span class="line">    raw_data_channel_len    = int(len(raw_data)/channel_list_len)</span><br><span class="line">    raw_data_list           = [bytearray()]*channel_list_len</span><br><span class="line">    for idx in range(0, channel_list_len):</span><br><span class="line">        raw_data_list[idx]  = raw_data[idx*raw_data_channel_len: (idx+1)*raw_data_channel_len]</span><br><span class="line">     </span><br><span class="line">    ## calculate the time axis  </span><br><span class="line">    time_data               = horiz_zero + (np.arange(data_len) - horiz_pt_offset)*horiz_xincr</span><br><span class="line">    </span><br><span class="line">    ## calculate the voltage axis</span><br><span class="line">    data_start_pos          = int( raw_data[1:2].decode(&#x27;ascii&#x27;), 16) + 2</span><br><span class="line">    current_pos             = 0</span><br><span class="line">        </span><br><span class="line">    if &#x27;RI&#x27; in data_format:</span><br><span class="line">        if nbytes_per_point == 1:        </span><br><span class="line">            unpack_fmt = &#x27;&gt;b&#x27;</span><br><span class="line">        elif nbytes_per_point == 2:</span><br><span class="line">            unpack_fmt = &#x27;&gt;h&#x27;        </span><br><span class="line">        elif nbytes_per_point == 4:  </span><br><span class="line">            unpack_fmt = &#x27;&gt;l&#x27;  </span><br><span class="line">               </span><br><span class="line">        volt_data = np.zeros((channel_list_len, data_len))</span><br><span class="line">        for idx, raw_data_channel in enumerate(raw_data_list):    </span><br><span class="line">            for idx_j in range(data_len):</span><br><span class="line">                current_pos             = data_start_pos + nbytes_per_point*idx_j</span><br><span class="line">                current_point           = raw_data_channel[current_pos:current_pos + nbytes_per_point]</span><br><span class="line">                current_volt_data       = digit_zero_list[idx] + digit_scale_list[idx]*\</span><br><span class="line">                                        (struct.unpack(unpack_fmt,current_point)[0] -digit_offset_list[idx])</span><br><span class="line">                volt_data[idx][idx_j]   = current_volt_data                            </span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for CURVE post processing is &#x27;, end-start,&#x27;s&#x27;)</span><br><span class="line">    ############################################################################</span><br><span class="line">      </span><br><span class="line">    return time_data, volt_data</span><br></pre></td></tr></table></figure>

<p>相对于原始的<code>transfer_wfm</code>函数，<code>transfer_wfm_se</code>函数做了如下优化：</p>
<ul>
<li>通过列表参数<code>channel_list</code>来支持多通道的波形传输；</li>
<li>以参数的形式将各个通道的波形垂直参数<code>digit_scale_list</code>，<code>digit_offset_list</code>，<code>digit_zero_list</code>传递给函数；</li>
<li>为了增加灵活性，我们提供了输入参数<code>data_start</code>，<code>data_stop</code>可以只对采集到的全部波形的一部分进行传输。</li>
</ul>
<p>6个通道的数据，采样率为625 MSps，记录长度为125 kpts，我们使用如下代码进行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    rm = visa.ResourceManager()</span><br><span class="line">    print(rm.list_resources())</span><br><span class="line">    resource_address= &#x27;TCPIP0::10.42.18.115::inst0::INSTR&#x27;</span><br><span class="line"></span><br><span class="line">    scope           = rm.open_resource(resource_address)</span><br><span class="line">    scope.timeout   = 4000</span><br><span class="line">    print( scope.query(&quot;*IDN?&quot;) )    </span><br><span class="line">    #scope.write(&#x27;FACtory&#x27;)</span><br><span class="line">    scope.write(&#x27;HEADer OFF&#x27;)</span><br><span class="line">    ############################################################################</span><br><span class="line"></span><br><span class="line">    ############################################################################</span><br><span class="line">    channel_list        = [&#x27;CH1&#x27; ,&#x27;CH2&#x27;, &#x27;CH3&#x27;, &#x27;CH4&#x27;, &#x27;CH5&#x27;, &#x27;CH6&#x27;]</span><br><span class="line">    channel_list_len    = len(channel_list)</span><br><span class="line"></span><br><span class="line">    scope.write(&#x27;DATa:ENCdg RIBinary&#x27;)</span><br><span class="line">    digit_scale_list    = [0]*channel_list_len</span><br><span class="line">    digit_offset_list   = [0]*channel_list_len</span><br><span class="line">    digit_zero_list     = [0]*channel_list_len         </span><br><span class="line">    for idx, channel in enumerate(channel_list):</span><br><span class="line">        scope.write(&#x27;DATa:SOUrce %s&#x27;%channel)</span><br><span class="line">        digit_scale_list[idx]   = float( scope.query(&#x27;WFMOutpre:YMUlt?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">        digit_offset_list[idx]  = float( scope.query(&#x27;WFMOutpre:YOFf?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">        digit_zero_list[idx]    = float( scope.query(&#x27;WFMOutpre:YZEro?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line"></span><br><span class="line">    record_length   = int( scope.query(&#x27;HORizontal:RECOrdlength?&#x27;).rstrip(&#x27;\n&#x27;) )</span><br><span class="line">    data_start      = 1</span><br><span class="line">    data_stop       = record_length   </span><br><span class="line">    ############################################################################</span><br><span class="line">    </span><br><span class="line">    ############################################################################ </span><br><span class="line">    start = time.time()</span><br><span class="line">    time_data, volt_data    = transfer_wfm_se(scope, channel_list, digit_scale_list, digit_offset_list, digit_zero_list, data_start, data_stop)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the total time is &#x27;, end-start,&#x27;s&#x27;)</span><br><span class="line"></span><br><span class="line">    plt.plot(time_data, volt_data[0])</span><br><span class="line">    plt.plot(time_data, volt_data[1])  </span><br><span class="line">    plt.plot(time_data, volt_data[2])</span><br><span class="line">    plt.plot(time_data, volt_data[3])</span><br><span class="line">    plt.plot(time_data, volt_data[4])</span><br><span class="line">    plt.plot(time_data, volt_data[5]) </span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br><span class="line">    ############################################################################  </span><br></pre></td></tr></table></figure>

<p>优化之后的结果，确实有所改善，测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;(&#x27;TCPIP0::10.42.19.60::inst0::INSTR&#x27;, &#x27;TCPIP0::10.42.18.115::inst0::INSTR&#x27;, &#x27;TCPIP0::10.42.18.183::inst0::INSTR&#x27;, &#x27;ASRL10::INSTR&#x27;)</span><br><span class="line">&gt;TEKTRONIX,MSO58B,C053854,CF:91.1CT FV:1.44.3.433</span><br><span class="line">&gt;the time for specifying data source is  0.00125885009765625 s</span><br><span class="line">&gt;the time for specifying data start/stop is  0.0020346641540527344 s</span><br><span class="line">&gt;the time for getting the waveform encoding infos is  0.005030155181884766 s</span><br><span class="line">&gt;the time for getting the horizontal infos is  0.06496262550354004 s</span><br><span class="line">&gt;the time for CURVE? query is  0.25408077239990234 s</span><br><span class="line">&gt;the time for CURVE post processing is  0.5736899375915527 s</span><br><span class="line">&gt;the total time is  0.9059956073760986 s</span><br></pre></td></tr></table></figure>

<p>速度上提升了一倍，降到了0.9s左右的时间，但是这还远远不够，需要进一步优化，可以发现时间主要花在<code>CURVE?</code>命令以及随之的二进制数据后处理上，这给我们指明了下一步优化的方向。</p>
<h1 id="持续改善"><a href="#持续改善" class="headerlink" title="持续改善"></a>持续改善</h1><p>根据上一节指明的优化方向，我们进一步做了如下优化，其源代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">def transfer_wfm_se_1(scope, channel_list, digit_scale_list, digit_offset_list, digit_zero_list, data_start, data_stop):</span><br><span class="line">    ############################################################################</span><br><span class="line">    ## specify channel sources of the transferred waveforms</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    channel_list_str    = &#x27;&#x27;</span><br><span class="line">    channel_list_len    = len(channel_list)</span><br><span class="line"></span><br><span class="line">    data_len = data_stop - data_start + 1</span><br><span class="line"></span><br><span class="line">    for channel in channel_list:</span><br><span class="line">        channel_list_str = channel_list_str + channel + &#x27;, &#x27;</span><br><span class="line">    channel_list_str = channel_list_str[0:-2]</span><br><span class="line">    scope.write(&#x27;DATa:SOUrce %s&#x27;%channel_list_str)</span><br><span class="line">    #scope.query(&#x27;DATa:SOUrce?&#x27;)</span><br><span class="line">    </span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for specifying data source is &#x27;, end-start,&#x27;s&#x27;) </span><br><span class="line">    #################################################################s</span><br><span class="line"></span><br><span class="line">    ############################################################################</span><br><span class="line">    scope.write(&#x27;DATa:ENCdg RIBinary&#x27;)</span><br><span class="line">    #scope.query(&#x27;DATa:ENCdg?&#x27;)</span><br><span class="line">    </span><br><span class="line">    scope.write(&#x27;WFMOutpre:BYT_Nr 2&#x27;)</span><br><span class="line">    #scope.query(&#x27;WFMOutpre:BYT_Nr?&#x27;)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    scope.write(&#x27;DATa:STARt %s&#x27;% data_start)   </span><br><span class="line">    scope.write(&#x27;DATa:STOP %s&#x27;% data_stop)</span><br><span class="line">    #scope.query(&#x27;DATa:STARt?&#x27;)</span><br><span class="line">    #scope.query(&#x27;DATa:STOP?&#x27;)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for specifying data start/stop is &#x27;, end-start,&#x27;s&#x27;)  </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    ## get the waveform infos(WFMOutpre?)</span><br><span class="line">    start = time.time()</span><br><span class="line">    scope.write(&#x27;WFMOutpre?&#x27;)</span><br><span class="line">    WFMOut_bytes        = scope.read_raw()</span><br><span class="line">    WFMOut_bytes_list   = WFMOut_bytes.split(b&#x27;;&#x27;)</span><br><span class="line">    data_format         = WFMOut_bytes_list[3].decode(&#x27;ascii&#x27;)</span><br><span class="line">    nbytes_per_point    = int(WFMOut_bytes_list[0].decode(&#x27;ascii&#x27;))</span><br><span class="line"></span><br><span class="line">    horiz_xincr         = float(WFMOut_bytes_list[11].decode(&#x27;ascii&#x27;))</span><br><span class="line">    horiz_xzero         = float(WFMOut_bytes_list[12].decode(&#x27;ascii&#x27;))</span><br><span class="line">    horiz_pt_offset     = int(WFMOut_bytes_list[13].decode(&#x27;ascii&#x27;))  </span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for getting the waveform infos(WFMOutpre?) is &#x27;, end-start,&#x27;s&#x27;)</span><br><span class="line">    ############################################################################</span><br><span class="line">    </span><br><span class="line">    ############################################################################</span><br><span class="line">    ## get the waveform data</span><br><span class="line">    start = time.time()</span><br><span class="line">    scope.write(&#x27;CURVE?&#x27;)</span><br><span class="line">    raw_data    = scope.read_raw()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for CURVE? query is &#x27;, end-start,&#x27;s&#x27;) </span><br><span class="line">    ############################################################################</span><br><span class="line"></span><br><span class="line">    ############################################################################</span><br><span class="line">    ## post-processing for curve raw data to real voltage data</span><br><span class="line">    start = time.time()</span><br><span class="line">    raw_data_channel_len    = int(len(raw_data)/channel_list_len)</span><br><span class="line">    raw_data_list           = [bytearray()]*channel_list_len</span><br><span class="line">    for idx in range(0, channel_list_len):</span><br><span class="line">        raw_data_list[idx]  = raw_data[idx*raw_data_channel_len: (idx+1)*raw_data_channel_len]</span><br><span class="line"></span><br><span class="line">    ## calculate the time axis  </span><br><span class="line">    time_data               = horiz_xzero + (np.arange(data_len) - horiz_pt_offset)*horiz_xincr</span><br><span class="line"></span><br><span class="line">    ## calculate the voltage axis        </span><br><span class="line">    if &#x27;RI&#x27; in data_format:</span><br><span class="line">        if nbytes_per_point == 1:        </span><br><span class="line">            unpack_fmt = &#x27;b&#x27;</span><br><span class="line">        elif nbytes_per_point == 2:</span><br><span class="line">            unpack_fmt = &#x27;h&#x27;        </span><br><span class="line">        elif nbytes_per_point == 4:  </span><br><span class="line">            unpack_fmt = &#x27;l&#x27;  </span><br><span class="line"></span><br><span class="line">        volt_data = np.zeros((channel_list_len, data_len))</span><br><span class="line">        for idx, raw_data_channel in enumerate(raw_data_list):</span><br><span class="line">            digit           = visa.util.from_ieee_block(raw_data_channel, unpack_fmt, 1)</span><br><span class="line">            volt_data[idx]  = digit_zero_list[idx] + digit_scale_list[idx]*(np.array(digit) -digit_offset_list[idx])  </span><br><span class="line"> </span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for CURVE post processing is &#x27;, end-start,&#x27;s&#x27;)</span><br><span class="line">    ############################################################################</span><br><span class="line">      </span><br><span class="line">    return time_data, volt_data</span><br></pre></td></tr></table></figure>

<p>相对于<code>transfer_wfm_se</code>函数，<code>transfer_wfm_se_1</code>函数做了如下两个方面的优化：</p>
<ul>
<li>在<code>transfer_wfm_se</code>函数中使用了若干个<code>WFMOutpre:xxxx?</code>查询命令来查询波形数据的编码信息和水平设置信息，这导致花费了较多的时间；因此在<code>transfer_wfm_se_1</code>中我们将这些查询命令合并，只使用一条命令<code>WFMOutpre?</code>来一次性获取波形的设置信息，然后在通过后处理分解出波形的变码信息和水平设置信息；</li>
<li>在获取到<code>CURVE?</code>命令的二进制波形数据做后处理时，<code>transfer_wfm_se</code>函数中使用了是python的for循环进行后处理，这样导致速度很慢。实际上<code>CURVE?</code>命令的二进制波形数据为IEEE 488.2规范中定义的二进制块数据，pyVISA中直接提供了相应的函数<code>from_ieee_block</code>来对之进行解析，我们将原来我们自己解析的代码改为使用<code>from_ieee_block</code>函数；</li>
</ul>
<p>经过上面两方面的改进，我们重新测试一下代码的速度，测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;(&#x27;TCPIP0::10.42.19.60::inst0::INSTR&#x27;, &#x27;TCPIP0::10.42.18.115::inst0::INSTR&#x27;, &#x27;TCPIP0::10.42.18.183::inst0::INSTR&#x27;, &#x27;ASRL10::INSTR&#x27;)</span><br><span class="line">&gt;TEKTRONIX,MSO58B,C053854,CF:91.1CT FV:1.44.3.433</span><br><span class="line">&gt;the time for specifying data source is  0.001013040542602539 s</span><br><span class="line">&gt;the time for specifying data start/stop is  0.0009989738464355469 s</span><br><span class="line">&gt;the time for getting the waveform infos(WFMOutpre?) is  0.060962677001953125 s</span><br><span class="line">&gt;the time for CURVE? query is  0.1600503921508789 s</span><br><span class="line">&gt;the time for CURVE post processing is  0.14691710472106934 s</span><br><span class="line">&gt;the total time is  0.3779325485229492 s</span><br></pre></td></tr></table></figure>

<p>函数的运行时间减小到了0.37 s,速度提升了2.5倍左右。<strong>优化似乎到这里已经到了尽头了，此时对于联合电子的0.6s要求已经可以满足了，但是对于斯达半导体的0.2s要求仍然没有满足</strong>。但是通过查阅<a href=""><strong>pyVISA</strong></a>中的源代码实现，我们又有了新的思路，进一步优化的函数代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">def transfer_wfm_se_2(scope, channel_list, digit_scale_list, digit_offset_list, digit_zero_list, data_start, data_stop):</span><br><span class="line">    ############################################################################</span><br><span class="line">    ## specify channel sources of the transferred waveforms</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    channel_list_str    = &#x27;&#x27;</span><br><span class="line">    channel_list_len    = len(channel_list)</span><br><span class="line"></span><br><span class="line">    data_len = data_stop - data_start + 1</span><br><span class="line"></span><br><span class="line">    for channel in channel_list:</span><br><span class="line">        channel_list_str = channel_list_str + channel + &#x27;, &#x27;</span><br><span class="line">    channel_list_str = channel_list_str[0:-2]</span><br><span class="line">    scope.write(&#x27;DATa:SOUrce %s&#x27;%channel_list_str)</span><br><span class="line">    #scope.query(&#x27;DATa:SOUrce?&#x27;)</span><br><span class="line">    </span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for specifying data source is &#x27;, end-start,&#x27;s&#x27;) </span><br><span class="line">    ############################################################################</span><br><span class="line"></span><br><span class="line">    ############################################################################</span><br><span class="line">    scope.write(&#x27;DATa:ENCdg RIBinary&#x27;)</span><br><span class="line">    #scope.query(&#x27;DATa:ENCdg?&#x27;)</span><br><span class="line">    </span><br><span class="line">    scope.write(&#x27;WFMOutpre:BYT_Nr 2&#x27;)</span><br><span class="line">    #scope.query(&#x27;WFMOutpre:BYT_Nr?&#x27;)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    scope.write(&#x27;DATa:STARt %s&#x27;% data_start)   </span><br><span class="line">    scope.write(&#x27;DATa:STOP %s&#x27;% data_stop)</span><br><span class="line">    #scope.query(&#x27;DATa:STARt?&#x27;)</span><br><span class="line">    #scope.query(&#x27;DATa:STOP?&#x27;)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for specifying data start/stop is &#x27;, end-start,&#x27;s&#x27;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ## get the waveform infos(WFMOutpre?)</span><br><span class="line">    start = time.time()</span><br><span class="line">    scope.write(&#x27;WFMOutpre?&#x27;)</span><br><span class="line">    WFMOut_bytes        = scope.read_raw()</span><br><span class="line">    WFMOut_bytes_list   = WFMOut_bytes.split(b&#x27;;&#x27;)</span><br><span class="line">    data_format         = WFMOut_bytes_list[3].decode(&#x27;ascii&#x27;)</span><br><span class="line">    nbytes_per_point    = int(WFMOut_bytes_list[0].decode(&#x27;ascii&#x27;))</span><br><span class="line"></span><br><span class="line">    horiz_xincr         = float(WFMOut_bytes_list[11].decode(&#x27;ascii&#x27;))</span><br><span class="line">    horiz_xzero         = float(WFMOut_bytes_list[12].decode(&#x27;ascii&#x27;))</span><br><span class="line">    horiz_pt_offset     = int(WFMOut_bytes_list[13].decode(&#x27;ascii&#x27;))    </span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for getting the waveform infos(WFMOutpre?) is &#x27;, end-start,&#x27;s&#x27;)</span><br><span class="line">    ############################################################################</span><br><span class="line">  </span><br><span class="line">    ############################################################################</span><br><span class="line">    ## get the waveform data</span><br><span class="line">    chunk_size          = nbytes_per_point*data_len*channel_list_len</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    scope.write(&#x27;CURVE?&#x27;)</span><br><span class="line">    raw_data            = scope.read_raw(chunk_size)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for CURVE? query is &#x27;, end-start,&#x27;s&#x27;) </span><br><span class="line">    ############################################################################</span><br><span class="line"></span><br><span class="line">    ############################################################################</span><br><span class="line">    ## post-processing for curve raw data to real voltage data</span><br><span class="line">    start = time.time()</span><br><span class="line">    raw_data_channel_len    = int(len(raw_data)/channel_list_len)</span><br><span class="line">    raw_data_list           = [bytearray()]*channel_list_len</span><br><span class="line">    for idx in range(0, channel_list_len):</span><br><span class="line">        raw_data_list[idx]  = raw_data[idx*raw_data_channel_len: (idx+1)*raw_data_channel_len]</span><br><span class="line"></span><br><span class="line">    ## calculate the time axis  </span><br><span class="line">    time_data               = horiz_xzero + (np.arange(data_len) - horiz_pt_offset)*horiz_xincr</span><br><span class="line"></span><br><span class="line">    ## calculate the voltage axis        </span><br><span class="line">    if &#x27;RI&#x27; in data_format:</span><br><span class="line">        if nbytes_per_point == 1:        </span><br><span class="line">            unpack_fmt = &#x27;&gt;b&#x27;</span><br><span class="line">        elif nbytes_per_point == 2:</span><br><span class="line">            unpack_fmt = &#x27;&gt;h&#x27;        </span><br><span class="line">        elif nbytes_per_point == 4:  </span><br><span class="line">            unpack_fmt = &#x27;&gt;l&#x27;  </span><br><span class="line">       </span><br><span class="line">        volt_data           = np.zeros((channel_list_len, data_len))</span><br><span class="line">        for idx, raw_data_channel in enumerate(raw_data_list):</span><br><span class="line">            offset, _       = visa.util.parse_ieee_block_header(raw_data_list[idx])</span><br><span class="line">            digit           = np.frombuffer(raw_data_channel, unpack_fmt, data_len, offset)</span><br><span class="line">            volt_data[idx]  = digit_zero_list[idx] + digit_scale_list[idx]*(np.array(digit) -digit_offset_list[idx])</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;the time for CURVE post processing is &#x27;, end-start,&#x27;s&#x27;)</span><br><span class="line">    ############################################################################</span><br><span class="line">      </span><br><span class="line">    return time_data, volt_data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相对于<code>transfer_wfm_se_1</code>函数，<code>transfer_wfm_se_2</code>函数做了如下两个方面的优化：</p>
<ul>
<li>通过查阅PyVISA的<code>read_raw</code>函数的实现，我们发现这个函数可以显式地提供一个<code>chunk_size</code>的参数；当用户不显式地提供这个参数时，<code>read_raw</code>函数在內部以<code>chunk_size = 10k</code>来进行一次数据地搬运，当数据量大大超过<code>chunk_size</code>的值时，pyVISA需要很多次的搬运才能完成整个数据的传输，众所周知，python作为一种解释性语言，其效率是很低的；因此<code>transfer_wfm_se_2</code>中我们显式地指定这个值；</li>
<li>在获取到<code>CURVE?</code>命令的二进制波形数据做后处理时，我们在<code>transfer_wfm_se_1</code>中使用的是函数<code>from_ieee_block</code>来对之进行解析，通过查阅函数<code>from_ieee_block</code>的实现，发现这一函数在某个条件被满足时会调用numpy中的<code>frombuffer</code>函数来完成数据的解析。因此在<code>transfer_wfm_se_2</code>中我们直接调用numpy中的<code>frombuffer</code>函数；</li>
</ul>
<p>经过上面两方面的改进，我们重新测试一下代码的速度，测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;(&#x27;TCPIP0::10.42.19.60::inst0::INSTR&#x27;, &#x27;TCPIP0::10.42.18.115::inst0::INSTR&#x27;, &#x27;TCPIP0::10.42.18.183::inst0::INSTR&#x27;, &#x27;ASRL10::INSTR&#x27;)</span><br><span class="line">&gt;TEKTRONIX,MSO58B,C053854,CF:91.1CT FV:1.44.3.433</span><br><span class="line">&gt;the time for specifying data source is  0.0009965896606445312 s</span><br><span class="line">&gt;the time for specifying data start/stop is  0.00200653076171875 s</span><br><span class="line">&gt;the time for getting the waveform infos(WFMOutpre?) is  0.04403877258300781 s</span><br><span class="line">&gt;the time for CURVE? query is  0.05996441841125488 s</span><br><span class="line">&gt;the time for CURVE post processing is  0.03597879409790039 s</span><br><span class="line">&gt;the total time is  0.16197896003723145 s</span><br></pre></td></tr></table></figure>

<p>至此我们把速度进一步提升，整个函数只需在0.16s左右的时间就完成6个通道波形电压数据的传输。从最初需要花费2.6s，经过一步一步的优化，我们最终只需要0.16s，速度提升有16倍之多，完美地解决了客户的痛点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/01/%E8%AE%B0%E5%BD%95%E7%A8%8B%E6%8E%A7%E4%BC%A0%E8%BE%93%E6%B3%A2%E5%BD%A2%E7%9A%84%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" data-id="cm45ij45e0000vow209mibgmg" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/12/01/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/01/%E8%AE%B0%E5%BD%95%E7%A8%8B%E6%8E%A7%E4%BC%A0%E8%BE%93%E6%B3%A2%E5%BD%A2%E7%9A%84%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/12/01/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>